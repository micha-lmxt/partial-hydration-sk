/* Take.svelte generated by Svelte v3.50.1 */
import {
	SvelteComponent,
	binding_callbacks,
	claim_element,
	create_slot,
	detach,
	element as element_1,
	get_all_dirty_from_scope,
	get_slot_changes,
	init,
	insert_hydration,
	safe_not_equal,
	transition_in,
	transition_out,
	update_slot_base
} from "svelte/internal";

function create_fragment(ctx:any[]) {
	let tag_1:Element;
	let current:boolean;
    let tag = ctx[1];
    let id = ctx[2]
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    const dummy = default_slot?document.createElement("dummy"):undefined;
	return {
		c() {
			tag_1 = element_1(tag);
			if (default_slot) default_slot.c();
		},
		l(nodes:ChildNode[]) {
            let _tag = tag;
            // if an id is supplied, try to infer tag from id
            if (id){
                for (let j=0;j<nodes.length;j++){
                    const n = nodes[j] as any;
                    if (n.id && n.id===id){
                        _tag = n.tagName;
                        break;
                    }
                }
            }
			tag_1 = claim_element(nodes, _tag.toUpperCase(),{id:true});
            
            if (default_slot) default_slot.c();
		},
		m(target:Node, anchor?:Node) {
			insert_hydration(target, tag_1, anchor);

			if (default_slot) {
				default_slot.m(dummy, null);
			}

			/*tag_1_binding*/ ctx[5](tag_1);
			current = true;
		},
		p(ctx:any[], [dirty]:[number]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local:any) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local:any) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching:boolean) {
			if (detaching) detach(tag_1);
			if (default_slot) default_slot.d(detaching);
			/*tag_1_binding*/ ctx[5](null);
		}
	};
}

function instance($$self:any, $$props:any, $$invalidate:any) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { element, tag, id } = $$props;

	function tag_1_binding($$value:any) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$$set = ($$props:any) => {
		if ('element' in $$props) $$invalidate(0, element = $$props.element);
		if ('tag' in $$props) $$invalidate(1, tag = $$props.tag);
        if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [element, tag, id, $$scope, slots, tag_1_binding];
}

class Take extends SvelteComponent {
	constructor(options:any) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { element: 0, tag: 1, id: 2 },undefined);
	}
}

export default Take;